CREATE TABLE "public"."users" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "name" character varying,
    "age" smallint,
    "avatar_url" text,
    "online" boolean DEFAULT false,
    "bio" text,
    "location" text,
    "personality_type" character varying(4),
    "emojis" text[],
    "personality_test_completed" boolean DEFAULT false NOT NULL,
    "is_admin" boolean DEFAULT false NOT NULL,
    "created_at" timestamz DEFAULT now() NOT NULL,
    "auth_id" uuid UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE
);

CREATE TABLE "public"."interests" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "name" text NOT NULL UNIQUE
);

CREATE TABLE "public"."user_interests" (
    "user_id" bigint NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    "interest_id" bigint NOT NULL REFERENCES public.interests(id) ON DELETE CASCADE,
    PRIMARY KEY (user_id, interest_id)
);

CREATE TABLE "public"."user_profile_images" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "user_id" bigint NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    "image_url" text NOT NULL,
    "created_at" timestamptz DEFAULT now() NOT NULL
);

CREATE TABLE "public"."user_traits" (
    "user_id" bigint NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    "trait" character varying NOT NULL,
    "value" smallint,
    PRIMARY KEY (user_id, trait)
);

CREATE TABLE "public"."organizations" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "name" character varying,
    "logo_url" text,
    "address" text,
    "description" text,
    "phone" character varying,
    "email" character varying,
    "website" character varying,
    "host_name" character varying,
    "organization_type" character varying,
    "facebook_url" character varying,
    "emojis" text[],
    "created_at" timestamptz DEFAULT now() NOT NULL,
    "auth_id" uuid UNIQUE REFERENCES auth.users(id) ON DELETE SET NULL
);

CREATE TABLE "public"."organization_opportunities" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "organization_id" bigint NOT NULL REFERENCES public.organizations(id) ON DELETE CASCADE,
    "name" character varying,
    "icon" character varying
);

CREATE TABLE "public"."organization_updates" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "organization_id" bigint NOT NULL REFERENCES public.organizations(id) ON DELETE CASCADE,
    "image_url" text
);

CREATE TABLE "public"."categories" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "name" text NOT NULL,
    "parent_id" bigint REFERENCES public.categories(id) ON DELETE CASCADE,
    "type" text NOT NULL -- 'event' or 'place'
);

CREATE TABLE "public"."events" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "title" character varying,
    "time" timestamptz,
    "host_name" character varying,
    "host_avatar_url" text,
    "icon" character varying,
    "color" character varying,
    "description" text,
    "image_url" text,
    "address" text,
    "organization_id" bigint REFERENCES public.organizations(id) ON DELETE CASCADE,
    "created_at" timestamptz DEFAULT now() NOT NULL,
    "end_time" timestamptz,
    "is_sponsored" boolean DEFAULT false,
    "offer" text,
    "category_id" bigint REFERENCES public.categories(id) ON DELETE SET NULL
);

CREATE TABLE "public"."event_images" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "event_id" bigint NOT NULL REFERENCES public.events(id) ON DELETE CASCADE,
    "image_url" text NOT NULL,
    "created_at" timestamptz DEFAULT now() NOT NULL
);

CREATE TABLE "public"."event_participants" (
    "event_id" bigint NOT NULL REFERENCES public.events(id) ON DELETE CASCADE,
    "user_id" bigint NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    PRIMARY KEY (event_id, user_id)
);

CREATE TABLE "public"."places" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "name" character varying,
    "offer" text,
    "address" text,
    "user_count" integer,
    "user_images" text[],
    "icon" character varying,
    "description" text,
    "is_sponsored" boolean,
    "phone" character varying,
    "opening_hours" text,
    "created_at" timestamptz DEFAULT now() NOT NULL,
    "organization_id" bigint REFERENCES public.organizations(id) ON DELETE CASCADE,
    "image_url" text,
    "category_id" bigint REFERENCES public.categories(id) ON DELETE SET NULL
);

CREATE TABLE "public"."place_images" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "place_id" bigint NOT NULL REFERENCES public.places(id) ON DELETE CASCADE,
    "image_url" text NOT NULL,
    "created_at" timestamptz DEFAULT now() NOT NULL
);

CREATE TABLE "public"."message_threads" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "last_message" text,
    "timestamp" timestamptz,
    "unread_count" integer,
    "match_timestamp" timestamptz,
    "created_at" timestamptz DEFAULT now() NOT NULL
);

CREATE TABLE "public"."message_thread_participants" (
    "thread_id" bigint NOT NULL REFERENCES public.message_threads(id) ON DELETE CASCADE,
    "user_id" bigint NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    PRIMARY KEY (thread_id, user_id)
);

CREATE TABLE "public"."messages" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "thread_id" bigint NOT NULL REFERENCES public.message_threads(id) ON DELETE CASCADE,
    "sender_id" bigint NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    "text" text,
    "image_url" text,
    "created_at" timestamptz DEFAULT now() NOT NULL
);

CREATE TABLE "public"."friends" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "user_id_1" bigint NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    "user_id_2" bigint NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    "status" character varying NOT NULL DEFAULT 'pending', -- pending, accepted, blocked
    "action_user_id" bigint NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    "created_at" timestamptz DEFAULT now() NOT NULL,
    CONSTRAINT "friends_user_order_check" CHECK (user_id_1 < user_id_2),
    UNIQUE (user_id_1, user_id_2)
);

CREATE TABLE "public"."user_reports" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "reporter_user_id" bigint NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    "reported_user_id" bigint NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    "reason" text NOT NULL,
    "comment" text,
    "status" character varying DEFAULT 'new' NOT NULL, -- new, under_review, resolved
    "created_at" timestamptz DEFAULT now() NOT NULL
);

CREATE TABLE "public"."checkins" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "place_id" bigint NOT NULL REFERENCES public.places(id) ON DELETE CASCADE,
    "user_id_1" bigint NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    "user_id_2" bigint NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    "created_at" timestamptz DEFAULT now() NOT NULL
);

CREATE TABLE "public"."drop_in_invitations" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "creator_user_id" bigint NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    "message" text NOT NULL,
    "location_name" character varying NOT NULL,
    "activity_icon" character varying NOT NULL,
    "expires_at" timestamptz NOT NULL,
    "created_at" timestamptz DEFAULT now() NOT NULL
);

-- Function to get the current user's public.users.id from their auth.uid()
-- This is more secure as it avoids giving broad SELECT permissions on the users table
-- for RLS policies on other tables.
CREATE OR REPLACE FUNCTION get_current_user_id()
RETURNS bigint AS $$
  SELECT id FROM public.users WHERE auth_id = auth.uid() LIMIT 1;
$$ LANGUAGE sql SECURITY DEFINER;


-- RLS Policies for Users
ALTER TABLE "public"."users" ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Authenticated users can see all users" ON "public"."users";
CREATE POLICY "Authenticated users can see all users" ON "public"."users"
AS PERMISSIVE FOR SELECT
TO authenticated
USING (true);

DROP POLICY IF EXISTS "Users can insert their own profile" ON "public"."users";
CREATE POLICY "Users can insert their own profile" ON "public"."users"
AS PERMISSIVE FOR INSERT
TO authenticated
WITH CHECK (auth.uid() = auth_id);

DROP POLICY IF EXISTS "Users can update their own profile" ON "public"."users";
CREATE POLICY "Users can update their own profile" ON "public"."users"
AS PERMISSIVE FOR UPDATE
TO authenticated
USING (auth.uid() = auth_id)
WITH CHECK (auth.uid() = auth_id);

DROP POLICY IF EXISTS "Users can delete their own profile" ON "public"."users";
CREATE POLICY "Users can delete their own profile" ON "public"."users"
AS PERMISSIVE FOR DELETE
TO authenticated
USING (auth.uid() = auth_id);


-- RLS Policies for Drop-in Invitations
ALTER TABLE "public"."drop_in_invitations" ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Allow authenticated users to read all drop-ins" ON "public"."drop_in_invitations";
CREATE POLICY "Allow authenticated users to read all drop-ins" ON "public"."drop_in_invitations"
AS PERMISSIVE FOR SELECT
TO authenticated
USING (true);

DROP POLICY IF EXISTS "Allow users to create their own drop-ins" ON "public"."drop_in_invitations";
CREATE POLICY "Allow users to create their own drop-ins" ON "public"."drop_in_invitations"
AS PERMISSIVE FOR INSERT
TO authenticated
WITH CHECK (creator_user_id = get_current_user_id());

-- RLS Policies for Event Participation
ALTER TABLE "public"."event_participants" ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Allow authenticated users to read event participants" ON "public"."event_participants";
CREATE POLICY "Allow authenticated users to read event participants" ON "public"."event_participants"
AS PERMISSIVE FOR SELECT
TO authenticated
USING (true);

-- FIX: Replaced subquery with a SECURITY DEFINER function call to avoid permission issues.
DROP POLICY IF EXISTS "Allow users to join events for themselves" ON "public"."event_participants";
CREATE POLICY "Allow users to join events for themselves" ON "public"."event_participants"
AS PERMISSIVE FOR INSERT
TO authenticated
WITH CHECK (user_id = get_current_user_id());

-- FIX: Replaced subquery with a SECURITY DEFINER function call to avoid permission issues.
DROP POLICY IF EXISTS "Allow users to leave events they have joined" ON "public"."event_participants";
CREATE POLICY "Allow users to leave events they have joined" ON "public"."event_participants"
AS PERMISSIVE FOR DELETE
TO authenticated
USING (user_id = get_current_user_id());