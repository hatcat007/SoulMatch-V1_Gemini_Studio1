-- SoulMatch Migration
-- version: 12.9
-- Fixes chat creation by introducing RPC functions to handle finding/creating threads atomically.
-- This simplifies client-side logic, avoids complex RLS issues, and makes the system more robust.

-- 1. Add creator_auth_id column if it doesn't exist.
ALTER TABLE public.message_threads
ADD COLUMN IF NOT EXISTS creator_auth_id uuid;

-- 2. Create helper function to get the current user's internal ID.
CREATE OR REPLACE FUNCTION public.get_current_user_id()
RETURNS bigint
LANGUAGE sql
STABLE
AS $$
  SELECT id FROM public.users WHERE auth_id = auth.uid() LIMIT 1;
$$;

-- 3. Create the RPC function for users to get or create a chat thread.
CREATE OR REPLACE FUNCTION public.get_or_create_chat_thread(p_friend_id bigint)
RETURNS bigint
LANGUAGE plpgsql
SECURITY DEFINER -- IMPORTANT: This allows the function to bypass RLS for its internal operations.
SET search_path = public
AS $$
DECLARE
  v_current_user_id bigint := get_current_user_id();
  v_existing_thread_id bigint;
  v_new_thread_id bigint;
BEGIN
  -- Check if a thread already exists between the two users.
  SELECT mtp1.thread_id INTO v_existing_thread_id
  FROM message_thread_participants mtp1
  JOIN message_thread_participants mtp2 ON mtp1.thread_id = mtp2.thread_id
  WHERE mtp1.user_id = v_current_user_id AND mtp2.user_id = p_friend_id;

  IF v_existing_thread_id IS NOT NULL THEN
    -- A thread exists, update its timestamp and return the ID.
    UPDATE message_threads SET match_timestamp = now() WHERE id = v_existing_thread_id;
    RETURN v_existing_thread_id;
  ELSE
    -- No thread exists, create a new one.
    INSERT INTO message_threads (creator_auth_id, match_timestamp)
    VALUES (auth.uid(), now())
    RETURNING id INTO v_new_thread_id;

    -- Add both users as participants.
    INSERT INTO message_thread_participants (thread_id, user_id)
    VALUES (v_new_thread_id, v_current_user_id), (v_new_thread_id, p_friend_id);

    RETURN v_new_thread_id;
  END IF;
END;
$$;

-- 4. Create the RPC function for admins to match all users.
CREATE OR REPLACE FUNCTION public.admin_match_all_users()
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_current_user_id bigint := get_current_user_id();
  v_is_current_user_admin boolean;
  v_user_ids bigint[];
  i int;
  j int;
  v_new_thread_id bigint;
  v_pair_count int := 0;
BEGIN
  -- 1. Check if the current user is an admin.
  SELECT is_admin INTO v_is_current_user_admin FROM public.users WHERE id = v_current_user_id;
  IF NOT v_is_current_user_admin THEN
    RAISE EXCEPTION 'Permission denied. User is not an admin.';
  END IF;

  -- 2. Delete all existing threads and participants.
  TRUNCATE public.message_thread_participants, public.messages, public.message_threads RESTART IDENTITY;

  -- 3. Get all user IDs.
  SELECT array_agg(id) INTO v_user_ids FROM public.users;

  -- 4. Create new threads for every pair of users.
  IF array_length(v_user_ids, 1) > 1 THEN
    FOR i IN 1..array_length(v_user_ids, 1) LOOP
      FOR j IN (i + 1)..array_length(v_user_ids, 1) LOOP
        -- Create thread
        INSERT INTO message_threads (creator_auth_id, match_timestamp)
        VALUES (auth.uid(), now())
        RETURNING id INTO v_new_thread_id;

        -- Add participants
        INSERT INTO message_thread_participants (thread_id, user_id)
        VALUES (v_new_thread_id, v_user_ids[i]), (v_new_thread_id, v_user_ids[j]);

        v_pair_count := v_pair_count + 1;
      END LOOP;
    END LOOP;
  END IF;

  RETURN 'Success! Matched ' || v_pair_count || ' pairs.';
END;
$$;

-- 5. RLS Policies
-- Enable RLS on all chat-related tables.
ALTER TABLE public.message_threads ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.message_thread_participants ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;

-- Drop all old policies to replace them.
DROP POLICY IF EXISTS "Allow authenticated users to create threads" ON public.message_threads;
DROP POLICY IF EXISTS "Allow users to access their own threads" ON public.message_threads;
DROP POLICY IF EXISTS "Allow users to see participants of their own threads" ON public.message_thread_participants;
DROP POLICY IF EXISTS "Allow users to add participants if they are friends or themselves" ON public.message_thread_participants;
DROP POLICY IF EXISTS "Allow users to see their own messages" ON public.messages;
DROP POLICY IF EXISTS "Allow users to send messages in their threads" ON public.messages;
DROP POLICY IF EXISTS "Allow access to own message threads" ON public.message_threads;
DROP POLICY IF EXISTS "Allow access to own thread participants" ON public.message_thread_participants;
DROP POLICY IF EXISTS "Allow access to messages in own threads" ON public.messages;

-- New, simplified policies. The RPC functions handle creation/admin security.
-- Policy for message_threads: Users can manage threads they are a part of.
CREATE POLICY "Allow access to own message threads" ON public.message_threads
FOR ALL USING (
  id IN (
    SELECT thread_id FROM public.message_thread_participants
    WHERE user_id = get_current_user_id()
  )
);

-- Policy for message_thread_participants: Users can manage participants of threads they are in.
CREATE POLICY "Allow access to own thread participants" ON public.message_thread_participants
FOR ALL USING (
  thread_id IN (
    SELECT thread_id FROM public.message_thread_participants
    WHERE user_id = get_current_user_id()
  )
);

-- Policy for messages: Users can manage messages in threads they are part of.
-- The WITH CHECK clause ensures a user can only insert messages as themself.
CREATE POLICY "Allow access to messages in own threads" ON public.messages
FOR ALL USING (
  thread_id IN (
    SELECT thread_id FROM public.message_thread_participants
    WHERE user_id = get_current_user_id()
  )
) WITH CHECK (
  sender_id = get_current_user_id()
);

-- 6. Grant execute permissions on the new functions
GRANT EXECUTE ON FUNCTION public.get_or_create_chat_thread(bigint) TO authenticated;
GRANT EXECUTE ON FUNCTION public.admin_match_all_users() TO authenticated;