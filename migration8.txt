-- SoulMatch Migration
-- version: 12.12
-- Fixes chat RLS recursion and INSERT issues.
-- This is a non-destructive script that can be run on an existing DB.

-- 1. Add creator_auth_id column if it doesn't exist.
ALTER TABLE public.message_threads
ADD COLUMN IF NOT EXISTS creator_auth_id uuid;

-- 2. Create helper function to get the current user's internal ID.
CREATE OR REPLACE FUNCTION public.get_current_user_id()
RETURNS bigint
LANGUAGE sql
STABLE
AS $$
  SELECT id FROM public.users WHERE auth_id = auth.uid() LIMIT 1;
$$;

-- 3. Create the RPC function for users to get or create a chat thread.
CREATE OR REPLACE FUNCTION public.get_or_create_chat_thread(p_friend_id bigint)
RETURNS bigint
LANGUAGE plpgsql
SECURITY DEFINER -- IMPORTANT: This allows the function to bypass RLS for its internal operations.
SET search_path = public
AS $$
DECLARE
  v_current_user_id bigint := get_current_user_id();
  v_existing_thread_id bigint;
  v_new_thread_id bigint;
BEGIN
  -- Check if a thread already exists between the two users.
  SELECT mtp1.thread_id INTO v_existing_thread_id
  FROM message_thread_participants mtp1
  JOIN message_thread_participants mtp2 ON mtp1.thread_id = mtp2.thread_id
  WHERE mtp1.user_id = v_current_user_id AND mtp2.user_id = p_friend_id;

  IF v_existing_thread_id IS NOT NULL THEN
    -- A thread exists, update its timestamp and return the ID.
    UPDATE message_threads SET match_timestamp = now() WHERE id = v_existing_thread_id;
    RETURN v_existing_thread_id;
  ELSE
    -- No thread exists, create a new one.
    INSERT INTO message_threads (creator_auth_id, match_timestamp)
    VALUES (auth.uid(), now())
    RETURNING id INTO v_new_thread_id;

    -- Add both users as participants.
    INSERT INTO message_thread_participants (thread_id, user_id)
    VALUES (v_new_thread_id, v_current_user_id), (v_new_thread_id, p_friend_id);

    RETURN v_new_thread_id;
  END IF;
END;
$$;

-- 4. Create the RPC function for admins to match all users.
CREATE OR REPLACE FUNCTION public.admin_match_all_users()
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_current_user_id bigint := get_current_user_id();
  v_is_current_user_admin boolean;
  v_user_ids bigint[];
  i int;
  j int;
  v_new_thread_id bigint;
  v_pair_count int := 0;
BEGIN
  -- 1. Check if the current user is an admin.
  SELECT is_admin INTO v_is_current_user_admin FROM public.users WHERE id = v_current_user_id;
  IF NOT v_is_current_user_admin THEN
    RAISE EXCEPTION 'Permission denied. User is not an admin.';
  END IF;

  -- 2. Delete all existing threads and participants.
  TRUNCATE public.message_thread_participants, public.messages, public.message_threads RESTART IDENTITY;

  -- 3. Get all user IDs.
  SELECT array_agg(id) INTO v_user_ids FROM public.users;

  -- 4. Create new threads for every pair of users.
  IF array_length(v_user_ids, 1) > 1 THEN
    FOR i IN 1..array_length(v_user_ids, 1) LOOP
      FOR j IN (i + 1)..array_length(v_user_ids, 1) LOOP
        -- Create thread
        INSERT INTO message_threads (creator_auth_id, match_timestamp)
        VALUES (auth.uid(), now())
        RETURNING id INTO v_new_thread_id;

        -- Add participants
        INSERT INTO message_thread_participants (thread_id, user_id)
        VALUES (v_new_thread_id, v_user_ids[i]), (v_new_thread_id, v_user_ids[j]);

        v_pair_count := v_pair_count + 1;
      END LOOP;
    END LOOP;
  END IF;

  RETURN 'Success! Matched ' || v_pair_count || ' pairs.';
END;
$$;

-- 5. Create a SECURITY DEFINER function to break RLS recursion.
CREATE OR REPLACE FUNCTION public.is_thread_participant(p_thread_id bigint)
RETURNS boolean
LANGUAGE sql
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT EXISTS (
    SELECT 1 FROM message_thread_participants
    WHERE thread_id = p_thread_id AND user_id = get_current_user_id()
  );
$$;

-- 6. RLS Policies
-- Drop all old policies to replace them with the non-recursive versions.
DROP POLICY IF EXISTS "Allow access to own message threads" ON public.message_threads;
DROP POLICY IF EXISTS "Allow access to own thread participants" ON public.message_thread_participants;
DROP POLICY IF EXISTS "Allow access to messages in own threads" ON public.messages;

-- Enable RLS on all chat-related tables.
ALTER TABLE public.message_threads ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.message_thread_participants ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;

-- New, simplified policies using the helper function.
CREATE POLICY "Allow access to own message threads" ON public.message_threads
FOR ALL USING (is_thread_participant(id));

CREATE POLICY "Allow access to own thread participants" ON public.message_thread_participants
FOR ALL USING (is_thread_participant(thread_id));

-- New, separated policies for messages table to fix INSERT bug.
CREATE POLICY "Allow read access to messages in own threads"
  ON public.messages FOR SELECT
  USING (is_thread_participant(thread_id));

CREATE POLICY "Allow insert of own messages"
  ON public.messages FOR INSERT
  WITH CHECK (sender_id = get_current_user_id());

CREATE POLICY "Allow update/delete of own messages"
  ON public.messages FOR UPDATE, DELETE
  USING (sender_id = get_current_user_id());

-- 7. Grant execute permissions on all functions
GRANT EXECUTE ON FUNCTION public.get_or_create_chat_thread(bigint) TO authenticated;
GRANT EXECUTE ON FUNCTION public.admin_match_all_users() TO authenticated;
GRANT EXECUTE ON FUNCTION public.is_thread_participant(bigint) TO authenticated;