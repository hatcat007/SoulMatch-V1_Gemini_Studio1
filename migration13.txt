-- SoulMatch Migration
-- version: 17.0
-- Implements a dynamic, database-driven notification system.

-- 1. Create the notifications table
CREATE TABLE IF NOT EXISTS "public"."notifications" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "user_id" bigint NOT NULL REFERENCES public.users(id) ON DELETE CASCADE, -- The recipient of the notification
    "actor_id" bigint REFERENCES public.users(id) ON DELETE CASCADE, -- The user who performed the action
    "type" text NOT NULL, -- e.g., 'new_message', 'friend_request'
    "message" text NOT NULL, -- The notification content
    "related_entity_id" bigint, -- ID of the chat thread, event, etc.
    "read" boolean DEFAULT false NOT NULL,
    "created_at" timestamptz DEFAULT now() NOT NULL
);
COMMENT ON COLUMN public.notifications.user_id IS 'The recipient of the notification';
COMMENT ON COLUMN public.notifications.actor_id IS 'The user who performed the action';
COMMENT ON COLUMN public.notifications.related_entity_id IS 'ID of the chat thread, event, etc.';

-- 2. Create function to handle new friend request notifications
CREATE OR REPLACE FUNCTION public.handle_new_friend_request_notification()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  recipient_user_id bigint;
  notification_message text;
BEGIN
  -- Only trigger for new pending requests
  IF TG_OP = 'INSERT' AND NEW.status = 'pending' THEN
    -- Determine who the recipient is (the user who did NOT send the request)
    IF NEW.user_id_1 = NEW.action_user_id THEN
      recipient_user_id := NEW.user_id_2;
    ELSE
      recipient_user_id := NEW.user_id_1;
    END IF;

    -- Create the notification message (UI will add the actor's name)
    notification_message := 'sendte dig en venneanmodning';

    -- Insert the notification
    INSERT INTO public.notifications (user_id, actor_id, type, message, related_entity_id)
    VALUES (recipient_user_id, NEW.action_user_id, 'friend_request', notification_message, NEW.id);
  END IF;
  RETURN NEW;
END;
$$;

-- 3. Create trigger for friend requests
DROP TRIGGER IF EXISTS on_new_friend_request ON public.friends;
CREATE TRIGGER on_new_friend_request
  AFTER INSERT ON public.friends
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_new_friend_request_notification();


-- 4. Create function to handle new message notifications
CREATE OR REPLACE FUNCTION public.handle_new_message_notification()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public -- required for security definer functions
AS $$
DECLARE
  recipient_user_id bigint;
  notification_message text;
BEGIN
  -- This handles 1-on-1 chats. For group chats, this would need to be a loop.
  SELECT user_id INTO recipient_user_id
  FROM message_thread_participants
  WHERE thread_id = NEW.thread_id AND user_id != NEW.sender_id
  LIMIT 1;

  IF recipient_user_id IS NOT NULL THEN
    -- Create the notification message (UI will add the actor's name)
    notification_message := 'sendte dig en besked';
    
    -- Insert the notification
    INSERT INTO public.notifications (user_id, actor_id, type, message, related_entity_id)
    VALUES (recipient_user_id, NEW.sender_id, 'message', notification_message, NEW.thread_id);
  END IF;
  RETURN NEW;
END;
$$;

-- 5. Create trigger for new messages
DROP TRIGGER IF EXISTS on_new_message ON public.messages;
CREATE TRIGGER on_new_message
  AFTER INSERT ON public.messages
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_new_message_notification();


-- 6. RLS Policies for notifications table
ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can only access their own notifications" ON public.notifications;
CREATE POLICY "Users can only access their own notifications"
  ON public.notifications
  FOR ALL
  USING ( (SELECT auth_id FROM public.users WHERE id = user_id) = auth.uid() );

-- 7. Grants
GRANT SELECT ON public.notifications TO authenticated;
GRANT INSERT, UPDATE, DELETE ON public.notifications TO authenticated; -- RLS will restrict to owner
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO authenticated;